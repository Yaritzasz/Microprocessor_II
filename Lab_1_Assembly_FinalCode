#include <Keypad.h>

/* Pins (Arduino Mega 2560) */
#define YELLOW   23
#define GREEN    27
#define RED      25
#define BUZZER   12   // Active buzzer

/* Keypad */
const byte ROWS = 4, COLS = 4;
char hexaKeys[ROWS][COLS] = {
  {'1','2','3','A'},
  {'4','5','6','B'},
  {'7','8','9','C'},
  {'*','0','#','D'}
};
byte rowPins[ROWS] = {9, 8, 7, 6};
byte colPins[COLS] = {5, 4, 3, 2};
Keypad keypad = Keypad(makeKeymap(hexaKeys), rowPins, colPins, ROWS, COLS);

/* Traffic State */
enum LedMode : uint8_t { OFF_MODE, RED_MODE, GREEN_MODE, YELLOW_MODE };
volatile LedMode currentMode = OFF_MODE;

volatile bool trafficRun = false;           // true when running cycle
volatile uint16_t secondsRemaining = 0;     // counts down every 1s (ISR)
volatile bool buzzerOn = false;             // ON in last 3s

// Startup blink (indefinite until first key)
volatile bool waitingForFirstKey = true;
volatile bool startupBlinkOn = false;       // toggled at 1 Hz by ISR

// User-set durations (seconds). MUST be set via keypad
volatile uint16_t redSec    = 0;
volatile uint16_t greenSec  = 0;
volatile uint16_t yellowSec = 3;

/* Input for duration setting */
enum InputTarget : uint8_t { NONE, SET_RED, SET_GREEN, SET_YELLOW };
InputTarget inputTarget = NONE;
char digitsBuf[5];     // up to 4 digits + '\0'
uint8_t digitsLen = 0;

/* Helpers */
static inline void setRGB(bool r, bool g, bool y) {
  digitalWrite(RED,   r ? HIGH : LOW);
  digitalWrite(GREEN, g ? HIGH : LOW);
  digitalWrite(YELLOW, y ? HIGH : LOW);
}

static inline void showModeSolid(LedMode m) {
  switch (m) {
    case RED_MODE:    setRGB(true,  false, false); break;
    case GREEN_MODE:  setRGB(false, true,  false); break;
    case YELLOW_MODE: setRGB(false, false, true);  break;
    default:          setRGB(false, false, false); break;
  }
}

static inline void startMode(LedMode m, uint16_t seconds) {
  currentMode = m;
  secondsRemaining = seconds;
  buzzerOn = false;
}

/*  Timer1 ISR @ 1 Hz */
ISR(TIMER1_COMPA_vect) {
  // Handle startup blink regardless of currentMode
  if (waitingForFirstKey) {
    startupBlinkOn = !startupBlinkOn;  // toggle red each second
    buzzerOn = false;
    return;
  }

  if (currentMode == OFF_MODE) {
    buzzerOn = false;
    return;
  }

  if (secondsRemaining > 0) {
    secondsRemaining--;

    // Last 3 seconds of current phase
    if (secondsRemaining > 0 && secondsRemaining <= 3) {
      buzzerOn = true;
    } else {
      buzzerOn = false;
    }
  }

  // Phase end: chain or stop
  if (secondsRemaining == 0) {
    if (trafficRun) {
      if      (currentMode == RED_MODE)    startMode(GREEN_MODE,  greenSec);
      else if (currentMode == GREEN_MODE)  startMode(YELLOW_MODE, yellowSec);
      else if (currentMode == YELLOW_MODE) startMode(RED_MODE,    redSec);
      else                                 currentMode = OFF_MODE;
    } else {
      currentMode = OFF_MODE;
      buzzerOn = false;
    }
  }
}

/* Keypad Input Logic */
void resetDigits() {
  digitsLen = 0;
  digitsBuf[0] = '\0';
}

void pushDigit(char k) {
  if (digitsLen < 4) {
    digitsBuf[digitsLen++] = k;
    digitsBuf[digitsLen] = '\0';
  }
}

void commitDigits() {
  if (digitsLen == 0) { inputTarget = NONE; return; }
  uint16_t val = (uint16_t)atoi(digitsBuf);
  if (val == 0) val = 1; // avoid zero-length phases

  noInterrupts();
  switch (inputTarget) {
    case SET_RED:    redSec    = val; break;
    case SET_GREEN:  greenSec  = val; break;
    case SET_YELLOW: yellowSec = val; break;
    default: break;
  }
  interrupts();

  inputTarget = NONE;
  resetDigits();
}

/* Setup */
void setup() {
  pinMode(RED, OUTPUT);
  pinMode(GREEN, OUTPUT);
  pinMode(YELLOW, OUTPUT);
  pinMode(BUZZER, OUTPUT);
  digitalWrite(BUZZER, LOW);
  setRGB(false, false, false);

  // ---- Timer1 @ 1 Hz (CTC) ----
  cli();
  TCCR1A = 0;
  TCCR1B = 0;
  TCNT1  = 0;
  OCR1A = 15624;                           // 1 Hz compare
  TCCR1B |= (1 << WGM12);                  // CTC mode
  TCCR1B |= (1 << CS12) | (1 << CS10);     // prescaler 1024
  TIMSK1 |= (1 << OCIE1A);                 // enable compare interrupt
  sei();
}

/* Main Loop */
void loop() {
  // --- Read keypad ---
  char k = keypad.getKey();
  if (k) {
    // stop startup blink on first keypress
    noInterrupts();
    if (waitingForFirstKey) {
      waitingForFirstKey = false;
      startupBlinkOn = false;
      setRGB(false, false, false);
    }
    interrupts();

// logic of stop light

    if (k == 'A') { inputTarget = SET_RED;    resetDigits(); }
    else if (k == 'B') { inputTarget = SET_GREEN;  resetDigits(); }
    else if (k >= '0' && k <= '9' && inputTarget != NONE) { pushDigit(k); }
    else if (k == '#' && inputTarget != NONE) { commitDigits(); }
    else if (k == '*') {
      bool canStart;
      noInterrupts();
      canStart = (redSec > 0 && greenSec > 0);
      if (canStart) {
        trafficRun = true;
        startMode(RED_MODE, redSec);
      }
      interrupts();
    }
    else if (k == 'D') {
      noInterrupts();
      trafficRun = false;
      currentMode = OFF_MODE;
      buzzerOn = false;
      interrupts();
    }
  }

  // Drive LEDs and buzzer based on current state (setting flags and variables)
  bool waitingSnap, startupBlinkSnap;
  noInterrupts();
  waitingSnap = waitingForFirstKey;
  startupBlinkSnap = startupBlinkOn;
  interrupts();

// on startup
  if (waitingSnap) {
    if (startupBlinkSnap) setRGB(true, false, false);
    else                  setRGB(false, false, false);
    digitalWrite(BUZZER, LOW);
    return;
  }
// buzzer activation
  LedMode modeSnapshot;
  bool buzzerSnap;
  uint16_t secsSnap;

  noInterrupts();
  modeSnapshot = currentMode;
  buzzerSnap   = buzzerOn;                 // buzzer turns on during last 3 sec
  secsSnap     = secondsRemaining;
  interrupts();

  digitalWrite(BUZZER, buzzerSnap ? HIGH : LOW);

  // turns off lights if no operation is running && 0.5 s blink in last 3 seconds
  static unsigned long lastHalfBlink = 0;
  static bool halfBlinkState = false;

  if (modeSnapshot == OFF_MODE) {
    setRGB(false, false, false);
  } else {
    if (secsSnap > 0 && secsSnap <= 3) {
      if (millis() - lastHalfBlink >= 500) {
        lastHalfBlink = millis();
        halfBlinkState = !halfBlinkState;
      }
      if (halfBlinkState) showModeSolid(modeSnapshot);
      else                setRGB(false, false, false);
    } else {
      showModeSolid(modeSnapshot);
      halfBlinkState = false;
    }
  }
}
