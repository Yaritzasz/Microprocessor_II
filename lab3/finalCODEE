/*
  Lab 3 – Step 7: DS1307 RTC + DC Motor + Direction Button + LCD + Sound Sensor
  -------------------------------------------------------------------------
  Converts sound level (A0) into discrete speed labels: "Full", "3/4", "1/2", or "0"
  and updates display once per second via Timer1 interrupt.
*/

#include <Wire.h>
#include <RTClib.h>
#include <LiquidCrystal.h>
#include <avr/interrupt.h>

RTC_DS1307 rtc;
LiquidCrystal lcd(7, 8, 9, 10, 11, 12);

// --- Motor pins ---
const int ENA = 5;
const int IN1 = 4;
const int IN2 = 3;

// --- Button ---
const int BTN_DIR = 2;
bool dirCW = true;
bool lastButtonState = HIGH;
unsigned long lastDebounce = 0;
const unsigned long debounceDelay = 200;

// --- Sound sensor ---
const int soundPin = A0;
int soundValue = 0;

// --- Speed & timing ---
int pwmSpeed = 0;
String speedLabel = "0";
const unsigned long RUN_DURATION = 30000;
bool motorRunning = false;
unsigned long motorStartTime = 0;
volatile bool updateDisplay = false;

void setup() {
  Serial.begin(9600);
  Serial.println("Lab 3 – Step 7: Sound Sensor Speed Levels");

  pinMode(ENA, OUTPUT);
  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT);
  pinMode(BTN_DIR, INPUT_PULLUP);
  pinMode(soundPin, INPUT);

  Wire.begin();
  if (!rtc.begin()) {
    Serial.println("RTC not found!");
    while (1);
  }
  if (!rtc.isrunning()) {
    Serial.println("RTC was stopped – starting clock now.");
    rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
  }

  lcd.begin(16, 2);
  lcd.clear();
  lcd.print("RTC + Motor + Mic");
  delay(1000);
  lcd.clear();

  // Timer1 setup for 1 Hz
  cli();
  TCCR1A = 0;
  TCCR1B = 0;
  TCNT1  = 0;
  OCR1A = 15624;                      // 1 Hz at 16 MHz/1024
  TCCR1B |= (1 << WGM12);
  TCCR1B |= (1 << CS12) | (1 << CS10);
  TIMSK1 |= (1 << OCIE1A);
  sei();
}

void loop() {
  // --- Button toggle ---
  bool reading = digitalRead(BTN_DIR);
  if (reading != lastButtonState && (millis() - lastDebounce) > debounceDelay) {
    lastDebounce = millis();
    if (reading == LOW) {
      dirCW = !dirCW;
      Serial.print("Direction changed to ");
      Serial.println(dirCW ? "CW" : "CCW");
      if (motorRunning) applyDirection();
    }
  }
  lastButtonState = reading;

  // --- Sound-sensor to speed mapping ---
  soundValue = analogRead(soundPin);

  if (soundValue < 109) {
    pwmSpeed = 0;
    speedLabel = "0";
  } else if (soundValue < 110) {
    pwmSpeed = 128;
    speedLabel = "1/2";
  } else if (soundValue < 135) {
    pwmSpeed = 192;
    speedLabel = "3/4";
  } else {
    pwmSpeed = 255;
    speedLabel = "Full";
  }

  // --- Motor run scheduling ---
  DateTime now = rtc.now();
  if (now.second() == 0 && !motorRunning) {
    Serial.println("New minute -> Motor ON for 30 s");
    startMotor();
    motorRunning = true;
    motorStartTime = millis();
  }

  if (motorRunning && (millis() - motorStartTime >= RUN_DURATION)) {
    stopMotor();
    motorRunning = false;
    Serial.println("Motor OFF");
  }

  // --- Update LCD once per second ---
  if (updateDisplay) {
    updateDisplay = false;
    updateLCD();
  }
}

// --- Timer1 ISR (1 Hz) ---
ISR(TIMER1_COMPA_vect) {
  updateDisplay = true;
}

// --- Helper functions ---
void startMotor() {
  applyDirection();
  analogWrite(ENA, pwmSpeed);
}

void stopMotor() {
  analogWrite(ENA, 0);
}

void applyDirection() {
  if (dirCW) {
    digitalWrite(IN1, HIGH);
    digitalWrite(IN2, LOW);
  } else {
    digitalWrite(IN1, LOW);
    digitalWrite(IN2, HIGH);
  }
}

void updateLCD() {
  DateTime now = rtc.now();
  char buf[9];
  sprintf(buf, "%02d:%02d:%02d", now.hour(), now.minute(), now.second());

  lcd.setCursor(0, 0);
  lcd.print(buf);
  lcd.print("   ");

  lcd.setCursor(0, 1);
  lcd.print("Dir:");
  lcd.print(dirCW ? "C " : "CC");
  lcd.print(" Spd:");
  lcd.print(speedLabel);
  lcd.print("   ");
}
