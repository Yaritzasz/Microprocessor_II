#include <Keypad.h>

/* ===================== Pin Assignments (Arduino Mega 2560) ===================== */
#define BLUE   23
#define GREEN  27
#define RED    25
#define BUZZER 12   // Active buzzer

/* ===================== Keypad Setup ===================== */
const byte ROWS = 4, COLS = 4;
char keys[ROWS][COLS] = {
  {'1','2','3','A'},
  {'4','5','6','B'},
  {'7','8','9','C'},
  {'*','0','#','D'}
};
byte rowPins[ROWS] = {9, 8, 7, 6};
byte colPins[COLS] = {5, 4, 3, 2};
Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);

/* ===================== State Variables ===================== */
enum Mode { STARTUP, RED_MODE, GREEN_MODE, YELLOW_MODE };
volatile Mode currentMode = STARTUP;

volatile uint16_t secondsRemaining = 0;
volatile bool halfSecondToggle = false;   // toggles every 0.5s for flashing
volatile bool buzzerOn = false;
volatile bool halfSecondPhase = false;    // helper for 0.5 Hz blink timing

// User-set durations (seconds)
volatile uint16_t redSec = 0;
volatile uint16_t greenSec = 0;
const uint16_t yellowSec = 3;

// Input handling
enum InputTarget { NONE, SET_RED, SET_GREEN };
InputTarget inputTarget = NONE;
char digitsBuf[5];
uint8_t digitsLen = 0;

/* ===================== Helper Functions ===================== */
static inline void setRGB(bool r, bool g, bool b) {
  digitalWrite(RED,   r ? HIGH : LOW);
  digitalWrite(GREEN, g ? HIGH : LOW);
  digitalWrite(BLUE,  b ? HIGH : LOW);
}

static inline void startPhase(Mode m, uint16_t sec) {
  currentMode = m;
  secondsRemaining = sec;
  buzzerOn = false;
}

/* ===================== Timer1 ISR =====================
   Fires every 0.5s for fine timing (so we can do 0.5s flashing)
   ====================================================== */
ISR(TIMER1_COMPA_vect) {
  halfSecondToggle = !halfSecondToggle;   // toggles every 0.5s
  static bool oneSecond = false;
  oneSecond = !oneSecond;  // toggles each interrupt → 1s every 2 calls

  if (currentMode == STARTUP) return;

  // Decrement once per second
  if (oneSecond && secondsRemaining > 0) {
    secondsRemaining--;

    // Turn buzzer ON during last 3 seconds
    buzzerOn = (secondsRemaining > 0 && secondsRemaining <= 3);
  }

  // When time expires, advance to next phase
  if (oneSecond && secondsRemaining == 0) {
    switch (currentMode) {
      case RED_MODE:    startPhase(GREEN_MODE, greenSec);  break;
      case GREEN_MODE:  startPhase(YELLOW_MODE, yellowSec); break;
      case YELLOW_MODE: startPhase(RED_MODE, redSec); break;
      default: break;
    }
  }
}

/* ===================== Input Helpers ===================== */
void resetDigits() {
  digitsLen = 0;
  digitsBuf[0] = '\0';
}

void pushDigit(char k) {
  if (digitsLen < 4) {
    digitsBuf[digitsLen++] = k;
    digitsBuf[digitsLen] = '\0';
  }
}

void commitDigits() {
  if (digitsLen == 0) { inputTarget = NONE; return; }
  uint16_t val = (uint16_t)atoi(digitsBuf);
  if (val == 0) val = 1;

  noInterrupts();
  if (inputTarget == SET_RED) redSec = val;
  else if (inputTarget == SET_GREEN) greenSec = val;
  interrupts();

  inputTarget = NONE;
  resetDigits();
}

/* ===================== Setup ===================== */
void setup() {
  pinMode(RED, OUTPUT);
  pinMode(GREEN, OUTPUT);
  pinMode(BLUE, OUTPUT);
  pinMode(BUZZER, OUTPUT);
  setRGB(false, false, false);
  digitalWrite(BUZZER, LOW);

  // Timer1 setup @ 0.5 Hz interrupt (every 0.5s)
  cli();
  TCCR1A = 0;
  TCCR1B = 0;
  TCNT1  = 0;
  // (16 MHz / 1024) = 15625 counts/sec → 7812 for 0.5s
  OCR1A = 7812;
  TCCR1B |= (1 << WGM12);                    // CTC mode
  TCCR1B |= (1 << CS12) | (1 << CS10);       // prescaler 1024
  TIMSK1 |= (1 << OCIE1A);                   // enable interrupt
  sei();
}

/* ===================== Main Loop ===================== */
void loop() {
  // --- Keypad input ---
  char k = keypad.getKey();
  if (k) {
    if (k == 'A') { inputTarget = SET_RED; resetDigits(); }
    else if (k == 'B') { inputTarget = SET_GREEN; resetDigits(); }
    else if (k >= '0' && k <= '9' && inputTarget != NONE) pushDigit(k);
    else if (k == '#' && inputTarget != NONE) commitDigits();
    else if (k == '*') {
      // Start only if both durations set
      noInterrupts();
      if (redSec > 0 && greenSec > 0)
        startPhase(RED_MODE, redSec);
      interrupts();
    }
  }

  // --- LED + Buzzer control ---
  bool buzzerSnap, toggleSnap;
  Mode modeSnap;
  uint16_t secSnap;

  noInterrupts();
  buzzerSnap = buzzerOn;
  toggleSnap = halfSecondToggle;
  modeSnap   = currentMode;
  secSnap    = secondsRemaining;
  interrupts();

  // Startup blinking (Red 1s on/off until * pressed)
  if (modeSnap == STARTUP) {
    if (toggleSnap) setRGB(true, false, false);
    else            setRGB(false, false, false);
    digitalWrite(BUZZER, LOW);
    return;
  }

  // Buzzer: ON during last 3 seconds, continuous
  digitalWrite(BUZZER, buzzerSnap ? HIGH : LOW);

  // LED control for each phase
  switch (modeSnap) {
    case RED_MODE:
      if (secSnap <= 3 && secSnap > 0)
        setRGB(toggleSnap, false, false); // flash 0.5s
      else
        setRGB(true, false, false);
      break;

    case GREEN_MODE:
      if (secSnap <= 3 && secSnap > 0)
        setRGB(false, toggleSnap, false); // flash 0.5s
      else
        setRGB(false, true, false);
      break;

    case YELLOW_MODE:
      setRGB(true, true, false); // steady yellow (R+G)
      break;

    default:
      setRGB(false, false, false);
      break;
  }
}
