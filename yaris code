#include <Keypad.h>

/* ===================== Pins (Arduino Mega 2560) ===================== */
#define BLUE   23
#define GREEN  27
#define RED    25
#define BUZZER 12   // Active buzzer

/* ===================== Keypad ===================== */
const byte ROWS = 4, COLS = 4;
char hexaKeys[ROWS][COLS] = {
  {'1','2','3','A'},
  {'4','5','6','B'},
  {'7','8','9','C'},
  {'*','0','#','D'}
};
byte rowPins[ROWS] = {9, 8, 7, 6};
byte colPins[COLS] = {5, 4, 3, 2};
Keypad keypad = Keypad(makeKeymap(hexaKeys), rowPins, colPins, ROWS, COLS);

/* ===================== Traffic State ===================== */
enum LedMode : uint8_t { OFF_MODE, RED_MODE, GREEN_MODE, YELLOW_MODE };
volatile LedMode currentMode = OFF_MODE;

volatile bool trafficRun = false;           // true when running * cycle
volatile uint16_t secondsRemaining = 0;     // counts down every 1s (ISR)
volatile bool phaseBlinkOn = false;         // 1 Hz in last 3s (phase)
volatile bool buzzerOn = false;             // ON in last 3s

// Startup blink (indefinite until first key)
volatile bool waitingForFirstKey = true;
volatile bool startupBlinkOn = false;       // toggled at 1 Hz by ISR

// User-set durations (seconds). MUST be set via keypad (no hard-coded defaults)
volatile uint16_t redSec    = 0;
volatile uint16_t greenSec  = 0;
volatile uint16_t yellowSec = 0;

/* ===================== Input for duration setting ===================== */
enum InputTarget : uint8_t { NONE, SET_RED, SET_GREEN, SET_YELLOW };
InputTarget inputTarget = NONE;
char digitsBuf[5];     // up to 4 digits (0..9999) + '\0'
uint8_t digitsLen = 0;

/* ===================== Helpers ===================== */
static inline void setRGB(bool r, bool g, bool b) {
  digitalWrite(RED,   r ? HIGH : LOW);
  digitalWrite(GREEN, g ? HIGH : LOW);
  digitalWrite(BLUE,  b ? HIGH : LOW);
}

// For "yellow", light RED+GREEN together
static inline void showModeSolid(LedMode m) {
  switch (m) {
    case RED_MODE:    setRGB(true,  false, false); break;
    case GREEN_MODE:  setRGB(false, true,  false); break;
    case YELLOW_MODE: setRGB(true,  true,  false); break; // RED+GREEN = yellow
    default:          setRGB(false, false, false); break;
  }
}

static inline void startMode(LedMode m, uint16_t seconds) {
  currentMode = m;
  secondsRemaining = seconds;
  phaseBlinkOn = false;
  buzzerOn = false;
}

/* ===================== Timer1 ISR @ 1 Hz ===================== */
ISR(TIMER1_COMPA_vect) {
  // Handle startup blink regardless of currentMode
  if (waitingForFirstKey) {
    startupBlinkOn = !startupBlinkOn;  // toggle red each second
    buzzerOn = false;
    return;
  }

  if (currentMode == OFF_MODE) {
    buzzerOn = false;
    return;
  }

  if (secondsRemaining > 0) {
    secondsRemaining--;

    // Last 3 seconds of current phase
    if (secondsRemaining > 0 && secondsRemaining <= 3) {
      buzzerOn = true;
      phaseBlinkOn = !phaseBlinkOn;   // toggle at 1 Hz
    } else {
      buzzerOn = false;
      phaseBlinkOn = false;
    }
  }

  // Phase end: chain or stop
  if (secondsRemaining == 0) {
    if (trafficRun) {
      if      (currentMode == RED_MODE)    startMode(GREEN_MODE,  greenSec);
      else if (currentMode == GREEN_MODE)  startMode(YELLOW_MODE, yellowSec);
      else if (currentMode == YELLOW_MODE) startMode(RED_MODE,    redSec);
      else                                 currentMode = OFF_MODE;
    } else {
      currentMode = OFF_MODE;
      buzzerOn = false;
      phaseBlinkOn = false;
    }
  }
}

/* ===================== Keypad Input Logic ===================== */
void resetDigits() {
  digitsLen = 0;
  digitsBuf[0] = '\0';
}

void pushDigit(char k) {
  if (digitsLen < 4) {
    digitsBuf[digitsLen++] = k;
    digitsBuf[digitsLen] = '\0';
  }
}

void commitDigits() {
  if (digitsLen == 0) { inputTarget = NONE; return; }
  uint16_t val = (uint16_t)atoi(digitsBuf);
  if (val == 0) val = 1; // avoid zero-length phases; smallest allowed is 1s

  noInterrupts();
  switch (inputTarget) {
    case SET_RED:    redSec    = val; break;
    case SET_GREEN:  greenSec  = val; break;
    case SET_YELLOW: yellowSec = val; break;
    default: break;
  }
  interrupts();

  inputTarget = NONE;
  resetDigits();
}

/* ===================== Setup ===================== */
void setup() {
  pinMode(RED, OUTPUT);
  pinMode(GREEN, OUTPUT);
  pinMode(BLUE, OUTPUT);
  pinMode(BUZZER, OUTPUT);
  digitalWrite(BUZZER, LOW);
  setRGB(false, false, false);

  // ---- Timer1 @ 1 Hz (CTC) ----
  cli();                // stop interrupts
  TCCR1A = 0;
  TCCR1B = 0;
  TCNT1  = 0;
  // (16 MHz) / (1024 prescaler) -> 15624 for 1 Hz (CTC)
  OCR1A = 15624;
  TCCR1B |= (1 << WGM12);                     // CTC mode
  TCCR1B |= (1 << CS12) | (1 << CS10);        // prescaler 1024
  TIMSK1 |= (1 << OCIE1A);                    // enable compare interrupt
  sei();                // allow interrupts
}

/* ===================== Main Loop ===================== */
void loop() {
  // --- Read keypad ---
  char k = keypad.getKey();
  if (k) {
    // stop startup blink on first keypress
    noInterrupts();
    if (waitingForFirstKey) {
      waitingForFirstKey = false;
      startupBlinkOn = false;
      setRGB(false, false, false);
    }
    interrupts();

    if (k == 'A') { inputTarget = SET_RED;    resetDigits(); }
    else if (k == 'B') { inputTarget = SET_GREEN;  resetDigits(); }
    else if (k >= '0' && k <= '9' && inputTarget != NONE) { pushDigit(k); }
    else if (k == '#' && inputTarget != NONE) { commitDigits(); }
    else if (k == '*') {
      // start traffic cycle from RED using current durations
      // Only start if ALL three durations are set (>0)
      bool canStart;
      noInterrupts();
      canStart = (redSec > 0 && greenSec > 0 && yellowSec > 0);
      if (canStart) {
        trafficRun = true;
        startMode(RED_MODE, redSec);
      }
      interrupts();
      // If not set, do nothing (user must input durations first)
    }
    else if (k == 'D') {
      // stop everything
      noInterrupts();
      trafficRun = false;
      currentMode = OFF_MODE;
      buzzerOn = false;
      phaseBlinkOn = false;
      interrupts();
    }
  }

  // --- Drive LEDs and buzzer based on current state ---

  // If still waiting for the first key, blink RED at 1 Hz
  bool waitingSnap, startupBlinkSnap;
  noInterrupts();
  waitingSnap = waitingForFirstKey;
  startupBlinkSnap = startupBlinkOn;
  interrupts();

  if (waitingSnap) {
    if (startupBlinkSnap) setRGB(true, false, false);
    else                  setRGB(false, false, false);
    digitalWrite(BUZZER, LOW);
    return;  // don't do anything else until first keypress
  }

  // Otherwise: normal phase behavior
  LedMode modeSnapshot;
  bool phaseBlinkSnap, buzzerSnap;
  uint16_t secsSnap;

  noInterrupts();
  modeSnapshot   = currentMode;
  phaseBlinkSnap = phaseBlinkOn;
  buzzerSnap     = buzzerOn;
  secsSnap       = secondsRemaining;
  interrupts();

  // Buzzer: ON in the last 3 seconds, else OFF
  digitalWrite(BUZZER, buzzerSnap ? HIGH : LOW);

  if (modeSnapshot == OFF_MODE) {
    setRGB(false, false, false);
  } else {
    if (secsSnap > 0 && secsSnap <= 3) {
      // 1 Hz blink (last 3 seconds)
      if (phaseBlinkSnap) showModeSolid(modeSnapshot);
      else                setRGB(false, false, false);
    } else {
      // steady
      showModeSolid(modeSnapshot);
    }
  }
}
